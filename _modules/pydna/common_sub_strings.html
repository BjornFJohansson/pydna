

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydna.common_sub_strings &mdash; pydna 6.0.0a24.post17+b7b559bd66 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=7ab3649f" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=a051be83" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=6efefdf6"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pydna
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Pydna</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/index.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example_gallery.html">Example gallery</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pydna</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../pydna.html">pydna</a></li>
      <li class="breadcrumb-item active">pydna.common_sub_strings</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pydna.common_sub_strings</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Copyright 2013-2023 by Björn Johansson.  All rights reserved.</span>
<span class="c1"># This code is part of the Python-dna distribution and governed by its</span>
<span class="c1"># license.  Please see the LICENSE.txt file that should have been included</span>
<span class="c1"># as part of this package.</span>

<span class="sd">&quot;&quot;&quot;This module is based on the Py-rstr-max package that</span>
<span class="sd">was written by Romain Brixtel (rbrixtel_at_gmail_dot_com)</span>
<span class="sd">(https://brixtel.users.greyc.fr) and is available from</span>
<span class="sd">https://code.google.com/p/py-rstr-max</span>
<span class="sd">https://github.com/gip0/py-rstr-max</span>
<span class="sd">the original code was covered by an MIT licence.&quot;&quot;&quot;</span>


<span class="c1"># from array import array as _array</span>
<span class="c1"># import itertools as _itertools</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span> <span class="k">as</span> <span class="n">_itemgetter</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span> <span class="k">as</span> <span class="n">_List</span><span class="p">,</span> <span class="n">Tuple</span> <span class="k">as</span> <span class="n">_Tuple</span>

<span class="n">Match</span> <span class="o">=</span> <span class="n">_Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>  <span class="c1"># (x_start, y_start, length)</span>

<span class="c1"># def _kark_sort(s, SA, n, K):</span>
<span class="c1">#     def radixpass(a, b, r, s, n, k):</span>
<span class="c1">#         c = _array(&quot;i&quot;, [0] * (k + 1))</span>
<span class="c1">#         for i in range(n):</span>
<span class="c1">#             c[r[a[i] + s]] += 1</span>

<span class="c1">#         somme = 0</span>
<span class="c1">#         for i in range(k + 1):</span>
<span class="c1">#             freq, c[i] = c[i], somme</span>
<span class="c1">#             somme += freq</span>

<span class="c1">#         for i in range(n):</span>
<span class="c1">#             b[c[r[a[i] + s]]] = a[i]</span>
<span class="c1">#             c[r[a[i] + s]] += 1</span>

<span class="c1">#     n0 = (n + 2) // 3</span>
<span class="c1">#     n1 = (n + 1) // 3</span>
<span class="c1">#     n2 = n // 3</span>
<span class="c1">#     n02 = n0 + n2</span>

<span class="c1">#     SA12 = _array(&quot;i&quot;, [0] * (n02 + 3))</span>
<span class="c1">#     SA0 = _array(&quot;i&quot;, [0] * n0)</span>

<span class="c1">#     s12 = [i for i in range(n + (n0 - n1)) if i % 3]</span>
<span class="c1">#     s12.extend([0] * 3)</span>
<span class="c1">#     s12 = _array(&quot;i&quot;, s12)</span>

<span class="c1">#     radixpass(s12, SA12, s, 2, n02, K)</span>
<span class="c1">#     radixpass(SA12, s12, s, 1, n02, K)</span>
<span class="c1">#     radixpass(s12, SA12, s, 0, n02, K)</span>

<span class="c1">#     name = 0</span>
<span class="c1">#     c0, c1, c2 = -1, -1, -1</span>
<span class="c1">#     for i in range(n02):</span>
<span class="c1">#         if s[SA12[i]] != c0 or s[SA12[i] + 1] != c1 or s[SA12[i] + 2] != c2:</span>
<span class="c1">#             name += 1</span>
<span class="c1">#             c0 = s[SA12[i]]</span>
<span class="c1">#             c1 = s[SA12[i] + 1]</span>
<span class="c1">#             c2 = s[SA12[i] + 2]</span>
<span class="c1">#         if SA12[i] % 3 == 1:</span>
<span class="c1">#             s12[SA12[i] // 3] = name</span>
<span class="c1">#         else:</span>
<span class="c1">#             s12[SA12[i] // 3 + n0] = name</span>

<span class="c1">#     if name &lt; n02:</span>
<span class="c1">#         _kark_sort(s12, SA12, n02, name + 1)</span>
<span class="c1">#         for i in range(n02):</span>
<span class="c1">#             s12[SA12[i]] = i + 1</span>
<span class="c1">#     else:</span>
<span class="c1">#         for i in range(n02):</span>
<span class="c1">#             SA12[s12[i] - 1] = i</span>

<span class="c1">#     s0 = _array(&quot;i&quot;, [SA12[i] * 3 for i in range(n02) if SA12[i] &lt; n0])</span>
<span class="c1">#     radixpass(s0, SA0, s, 0, n0, K)</span>

<span class="c1">#     p = j = k = 0</span>
<span class="c1">#     t = n0 - n1</span>
<span class="c1">#     while k &lt; n:</span>
<span class="c1">#         i = SA12[t] * 3 + 1 if SA12[t] &lt; n0 else (SA12[t] - n0) * 3 + 2</span>
<span class="c1">#         j = SA0[p] if p &lt; n0 else 0</span>

<span class="c1">#         if SA12[t] &lt; n0:</span>
<span class="c1">#             test = (s12[SA12[t] + n0] &lt;= s12[j // 3]) if (s[i] == s[j]) else (s[i] &lt; s[j])</span>
<span class="c1">#         elif s[i] == s[j]:</span>
<span class="c1">#             test = s12[SA12[t] - n0 + 1] &lt;= s12[j // 3 + n0] if (s[i + 1] == s[j + 1]) else s[i + 1] &lt; s[j + 1]</span>
<span class="c1">#         else:</span>
<span class="c1">#             test = s[i] &lt; s[j]</span>
<span class="c1">#         if test:</span>
<span class="c1">#             SA[k] = i</span>
<span class="c1">#             t += 1</span>
<span class="c1">#             if t == n02:</span>
<span class="c1">#                 k += 1</span>
<span class="c1">#                 while p &lt; n0:</span>
<span class="c1">#                     SA[k] = SA0[p]</span>
<span class="c1">#                     p += 1</span>
<span class="c1">#                     k += 1</span>
<span class="c1">#         else:</span>
<span class="c1">#             SA[k] = j</span>
<span class="c1">#             p += 1</span>
<span class="c1">#             if p == n0:</span>
<span class="c1">#                 k += 1</span>
<span class="c1">#                 while t &lt; n02:</span>
<span class="c1">#                     SA[k] = (SA12[t] * 3) + 1 if SA12[t] &lt; n0 else ((SA12[t] - n0) * 3) + 2</span>
<span class="c1">#                     t += 1</span>
<span class="c1">#                     k += 1</span>
<span class="c1">#         k += 1</span>


<span class="c1"># class _Rstr_max:</span>
<span class="c1">#     def __init__(self):</span>
<span class="c1">#         self.array_str = []</span>

<span class="c1">#     def add_str(self, str_unicode):</span>
<span class="c1">#         self.array_str.append(str_unicode)</span>

<span class="c1">#     def _step1_sort_suffix(self):</span>
<span class="c1">#         char_frontier = chr(2)</span>

<span class="c1">#         self.global_suffix = char_frontier.join(self.array_str)</span>

<span class="c1">#         nbChars = len(self.global_suffix)</span>
<span class="c1">#         init = [-1] * nbChars</span>
<span class="c1">#         self.idxString = _array(&quot;i&quot;, init)</span>
<span class="c1">#         self.idxPos = _array(&quot;i&quot;, init)</span>
<span class="c1">#         self.endAt = _array(&quot;i&quot;, init)</span>

<span class="c1">#         k = idx = 0</span>
<span class="c1">#         for mot in self.array_str:</span>
<span class="c1">#             last = k + len(mot)</span>
<span class="c1">#             for p in range(len(mot)):</span>
<span class="c1">#                 self.idxString[k] = idx</span>
<span class="c1">#                 self.idxPos[k] = p</span>
<span class="c1">#                 self.endAt[k] = last</span>
<span class="c1">#                 k += 1</span>
<span class="c1">#             idx += 1</span>
<span class="c1">#             k += 1</span>

<span class="c1">#         s = self.global_suffix</span>
<span class="c1">#         alphabet = [None] + sorted(set(s))</span>
<span class="c1">#         k = len(alphabet)</span>
<span class="c1">#         n = len(s)</span>
<span class="c1">#         t = dict((c, i) for i, c in enumerate(alphabet))</span>
<span class="c1">#         SA = _array(&quot;i&quot;, [0] * (n + 3))</span>
<span class="c1">#         _kark_sort(_array(&quot;i&quot;, [t[c] for c in s] + [0] * 3), SA, n, k)</span>
<span class="c1">#         self.res = SA[:n]</span>

<span class="c1">#     def _step2_lcp(self):</span>
<span class="c1">#         n = len(self.res)</span>
<span class="c1">#         init = [0] * n</span>
<span class="c1">#         rank = _array(&quot;i&quot;, init)</span>
<span class="c1">#         LCP = _array(&quot;i&quot;, init)</span>

<span class="c1">#         s = self.global_suffix</span>
<span class="c1">#         suffix__array = self.res</span>
<span class="c1">#         endAt = self.endAt</span>

<span class="c1">#         for i in range(len(self.array_str), n):</span>
<span class="c1">#             v = self.res[i]</span>
<span class="c1">#             rank[v] = i</span>

<span class="c1">#         l = 0</span>
<span class="c1">#         for j in range(n):</span>
<span class="c1">#             if l &gt; 0:</span>
<span class="c1">#                 l -= 1</span>
<span class="c1">#             i = rank[j]</span>
<span class="c1">#             j2 = suffix__array[i - 1]</span>
<span class="c1">#             if i:</span>
<span class="c1">#                 while l + j &lt; endAt[j] and l + j2 &lt; endAt[j2] and s[j + l] == s[j2 + l]:</span>
<span class="c1">#                     l += 1</span>
<span class="c1">#                 LCP[i - 1] = l</span>
<span class="c1">#             else:</span>
<span class="c1">#                 l = 0</span>
<span class="c1">#         self.lcp = LCP</span>

<span class="c1">#     def _step3_rstr(self):</span>
<span class="c1">#         prev_len = 0</span>
<span class="c1">#         idx = 0</span>
<span class="c1">#         results = {}</span>
<span class="c1">#         len_lcp = len(self.lcp) - 1</span>

<span class="c1">#         class Stack:</span>
<span class="c1">#             pass</span>

<span class="c1">#         stack = Stack()</span>
<span class="c1">#         stack._top = 0</span>
<span class="c1">#         stack.lst_max = []</span>

<span class="c1">#         # if len(self.res) == 0 :</span>
<span class="c1">#         #  return {}</span>

<span class="c1">#         pos1 = self.res[0]</span>
<span class="c1">#         for idx in range(len_lcp):</span>
<span class="c1">#             current_len = self.lcp[idx]</span>
<span class="c1">#             pos2 = self.res[idx + 1]</span>
<span class="c1">#             end_ = max(pos1, pos2) + current_len</span>
<span class="c1">#             n = prev_len - current_len</span>
<span class="c1">#             if n &lt; 0:</span>
<span class="c1">#                 # pushMany</span>
<span class="c1">#                 stack.lst_max.append([-n, idx, end_])</span>
<span class="c1">#                 stack._top += -n</span>
<span class="c1">#             elif n &gt; 0:</span>
<span class="c1">#                 self.removeMany(stack, results, n, idx)</span>
<span class="c1">#             elif stack._top &gt; 0 and end_ &gt; stack.lst_max[-1][-1]:</span>
<span class="c1">#                 # setMax</span>
<span class="c1">#                 stack.lst_max[-1][-1] = end_</span>

<span class="c1">#             prev_len = current_len</span>
<span class="c1">#             pos1 = pos2</span>

<span class="c1">#         if stack._top &gt; 0:</span>
<span class="c1">#             self.removeMany(stack, results, stack._top, idx + 1)</span>

<span class="c1">#         return results</span>

<span class="c1">#     def removeMany(self, stack, results, m, idxEnd):</span>
<span class="c1">#         prevStart = -1</span>
<span class="c1">#         while m &gt; 0:</span>
<span class="c1">#             n, idxStart, maxEnd = stack.lst_max.pop()</span>
<span class="c1">#             if prevStart != idxStart:</span>
<span class="c1">#                 # idStr = self.idxString[maxEnd-1]</span>
<span class="c1">#                 # pos = self.idxPos[maxEnd-1]</span>
<span class="c1">#                 id_ = (maxEnd, idxEnd - idxStart + 1)</span>
<span class="c1">#                 if id_ not in results or results[id_][0] &lt; stack._top:</span>
<span class="c1">#                     results[id_] = (stack._top, idxStart)</span>
<span class="c1">#                 prevStart = idxStart</span>
<span class="c1">#             m -= n</span>
<span class="c1">#             stack._top -= n</span>
<span class="c1">#         if m &lt; 0:</span>
<span class="c1">#             stack.lst_max.append([-m, idxStart, maxEnd - n - m])</span>
<span class="c1">#             stack._top -= m</span>

<span class="c1">#     def go(self):</span>
<span class="c1">#         self._step1_sort_suffix()</span>
<span class="c1">#         self._step2_lcp()</span>
<span class="c1">#         return self._step3_rstr()</span>


<span class="c1"># def common_sub_strings_py(stringx: str, stringy: str, limit=25):</span>
<span class="c1">#     &quot;&quot;&quot;Finds all common substrings between stringx and stringy</span>
<span class="c1">#     longer than limit. This function is case sensitive.</span>
<span class="c1">#     The substrings may overlap.</span>

<span class="c1">#     returns a list of tuples describing the substrings</span>
<span class="c1">#     The list is sorted longest -&gt; shortest.</span>

<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     stringx : str</span>
<span class="c1">#     stringy : str</span>
<span class="c1">#     limit : int, optional</span>

<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     list of tuple</span>
<span class="c1">#         [(startx1, starty1, length1),(startx2, starty2, length2), ...]</span>

<span class="c1">#         startx1 = startposition in x, where substring 1 starts</span>
<span class="c1">#         starty1 = position in y where substring 1 starts</span>
<span class="c1">#         length1 = lenght of substring</span>


<span class="c1">#     Examples</span>
<span class="c1">#     --------</span>

<span class="c1">#     &gt;&gt;&gt; from pydna.common_sub_strings import common_sub_strings</span>
<span class="c1">#     &gt;&gt;&gt; common_sub_strings(&quot;gatgatttcggtagtta&quot;, &quot;gtcagtatgtctatctatcgcg&quot;, limit=3)</span>
<span class="c1">#     [(1, 6, 3), (7, 17, 3), (10, 4, 3), (12, 3, 3)]</span>

<span class="c1">#     ::</span>

<span class="c1">#         Overlaps   Symbols</span>
<span class="c1">#         (1, 6,  3)   ---</span>
<span class="c1">#         (7, 17, 3)   +++</span>
<span class="c1">#         (10, 4, 3)   ...</span>
<span class="c1">#         (12, 3, 3)   ===</span>


<span class="c1">#                     ===</span>
<span class="c1">#         gatgatttcggtagtta           stringx</span>
<span class="c1">#          ---   +++...</span>

<span class="c1">#             ...</span>
<span class="c1">#         gtcagtatgtctatctatcgcg      stringy</span>
<span class="c1">#            ===---        +++</span>

<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     rstr = _Rstr_max()</span>
<span class="c1">#     rstr.add_str(&quot;&amp;&quot;.join((stringx, stringy)))</span>
<span class="c1">#     r = rstr.go()</span>
<span class="c1">#     match = {}</span>
<span class="c1">#     for (offset_end, nb), (l, start_plage) in r.items():</span>
<span class="c1">#         if l &lt; limit:</span>
<span class="c1">#             continue</span>
<span class="c1">#         startsx = []</span>
<span class="c1">#         startsy = []</span>
<span class="c1">#         for o in range(start_plage, start_plage + nb):</span>
<span class="c1">#             offset = rstr.idxPos[rstr.res[o]]</span>
<span class="c1">#             if offset &gt; len(stringx):</span>
<span class="c1">#                 startsy.append(offset - len(stringx) - 1)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 startsx.append(offset)</span>

<span class="c1">#         for a, b in _itertools.product(startsx, startsy):</span>
<span class="c1">#             match[(a, b)] = max(match.get((a, b)) or 0, l)</span>

<span class="c1">#     match = [(key[0], key[1], val) for key, val in list(match.items())]</span>

<span class="c1">#     match.sort()</span>

<span class="c1">#     match.sort(key=_itemgetter(2), reverse=True)</span>

<span class="c1">#     return match</span>


<div class="viewcode-block" id="common_sub_strings"><a class="viewcode-back" href="../../modules/pydna_common_sub_strings.html#pydna.common_sub_strings.common_sub_strings">[docs]</a><span class="k">def</span> <span class="nf">common_sub_strings</span><span class="p">(</span><span class="n">stringx</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">stringy</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">25</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_List</span><span class="p">[</span><span class="n">Match</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds all common substrings between stringx and stringy, and returns</span>
<span class="sd">    them sorted by length.</span>

<span class="sd">    This function is case sensitive.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stringx : str</span>
<span class="sd">    stringy : str</span>
<span class="sd">    limit : int, optional</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of tuple</span>
<span class="sd">        [(startx1, starty1, length1),(startx2, starty2, length2), ...]</span>

<span class="sd">        startx1 = startposition in x, where substring 1 starts</span>
<span class="sd">        starty1 = position in y where substring 1 starts</span>
<span class="sd">        length1 = lenght of substring</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">pydivsufsort</span> <span class="kn">import</span> <span class="n">common_substrings</span>

    <span class="n">matches</span> <span class="o">=</span> <span class="n">common_substrings</span><span class="p">(</span><span class="n">stringx</span><span class="p">,</span> <span class="n">stringy</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
    <span class="n">matches</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">matches</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">_itemgetter</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">matches</span></div>


<div class="viewcode-block" id="terminal_overlap"><a class="viewcode-back" href="../../modules/pydna_common_sub_strings.html#pydna.common_sub_strings.terminal_overlap">[docs]</a><span class="k">def</span> <span class="nf">terminal_overlap</span><span class="p">(</span><span class="n">stringx</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">stringy</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_List</span><span class="p">[</span><span class="n">Match</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finds the the flanking common substrings between stringx and stringy</span>
<span class="sd">    longer than limit. This means that the results only contains substrings</span>
<span class="sd">    that starts or ends at the the ends of stringx and stringy.</span>

<span class="sd">    This function is case sensitive.</span>

<span class="sd">    returns a list of tuples describing the substrings</span>
<span class="sd">    The list is sorted longest -&gt; shortest.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stringx : str</span>
<span class="sd">    stringy : str</span>
<span class="sd">    limit : int, optional</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of tuple</span>
<span class="sd">        [(startx1,starty1,length1),(startx2,starty2,length2), ...]</span>

<span class="sd">        startx1 = startposition in x, where substring 1 starts</span>
<span class="sd">        starty1 = position in y where substring 1 starts</span>
<span class="sd">        length1 = lenght of substring</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from pydna.common_sub_strings import terminal_overlap</span>
<span class="sd">    &gt;&gt;&gt; terminal_overlap(&quot;agctatgtatcttgcatcgta&quot;, &quot;gcatcgtagtctatttgcttac&quot;, limit=8)</span>
<span class="sd">    [(13, 0, 8)]</span>

<span class="sd">    ::</span>

<span class="sd">                        &lt;-- 8 -&gt;</span>
<span class="sd">           &lt;---- 13 ---&gt;</span>
<span class="sd">           agctatgtatcttgcatcgta                    stringx</span>
<span class="sd">                        gcatcgtagtctatttgcttac      stringy</span>
<span class="sd">                        0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">m</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">common_sub_strings</span><span class="p">(</span><span class="n">stringx</span><span class="p">,</span> <span class="n">stringy</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">stringy</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">stringx</span><span class="p">))</span>
    <span class="p">]</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">os</span> <span class="k">as</span> <span class="nn">_os</span>

    <span class="n">cached</span> <span class="o">=</span> <span class="n">_os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;pydna_cached_funcs&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">_os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;pydna_cached_funcs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">doctest</span>

    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optionflags</span><span class="o">=</span><span class="n">doctest</span><span class="o">.</span><span class="n">ELLIPSIS</span><span class="p">)</span>
    <span class="n">_os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;pydna_cached_funcs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cached</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Björn F. Johansson.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>